// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the Python
// language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <Python.h>
#include <vector>
#include <string>

static PyObject* py_module;
static PyObject* champ_module;


/// Type de personnage
typedef enum perso_classe
{
    PERSO_VOLEUR, ///< Voleur
    PERSO_BARBARE, ///< Barbare
    PERSO_ELFE, ///< Elfe
} perso_classe;

/// Type de zone
typedef enum zone_type
{
    ZONE_HERBE, ///< Herbe
    ZONE_ROUTE, ///< Route
    ZONE_FORET, ///< Forêt
    ZONE_MARAIS, ///< Marais
    ZONE_MUR, ///< Mur
    ZONE_TOUR, ///< Tour de guet
    ZONE_ERREUR, ///< Erreur, case impossible
} zone_type;

/// Type d'attaque
typedef enum attaque_type
{
    ATTAQUE_NORMALE, ///< Attaque normale dont les dégats dépendent du personnage
    ATTAQUE_PALANTIR, ///< Attaque 'Palantir' du Voleur
    ATTAQUE_TRAITRISE, ///< Attaque 'Traîtrise' du Voleur
    ATTAQUE_BASTOOOON, ///< Attaque 'Bastoooon' de du Barbare
    ATTAQUE_FUS_RO_DAH, ///< Attaque 'Fus Ro Dah' du Barbare
    ATTAQUE_I_SEE, ///< Attaque 'I see what you did there.' de l'Elfe
    ATTAQUE_LOTO, ///< Attaque 'Loto, à qui le tour' de l'Elfe
} attaque_type;

/// Orientation du personnage
typedef enum orientation
{
    ORIENTATION_NORD, ///< Orienté au nord
    ORIENTATION_EST, ///< Orienté à l'est
    ORIENTATION_SUD, ///< Orienté au sud
    ORIENTATION_OUEST, ///< Orienté à l'ouest
} orientation;

/// Erreurs possibles
typedef enum erreur
{
    POSITION_IMPOSSIBLE, ///< La position n'existe pas
    PERSONNAGE_IMPOSSIBLE, ///< Le personnage n'existe pas ou ne vous appartient pas
    CHEMIN_IMPOSSIBLE, ///< Le chemin est impossible
    ATTAQUE_INDISPONIBLE, ///< L'attaque n'est pas utilisable pour le moment
    OK, ///< Pas d'erreur
} erreur;

/// Représente une position sur le terrain du jeu
typedef struct position
{
    int x; ///< coordonnée en X
    int y; ///< coordonnée en Y
} position;

/// Représente les informations sur un personnage
typedef struct perso_info
{
    int equipe; ///< Équipe à laquelle appartient le personnage
    perso_classe classe; ///< Classe du personnage
    int vie; ///< Vie courante du personnage
    orientation direction; ///< Orientation du personnage
} perso_info;

extern "C" {

/// Retourne la taille de la carte.
position api_carte_taille();

/// Retourne la position de départ des personnages sur la map.
position api_carte_depart();

/// Retourne la nature de la zone désignée par ``pos``.
zone_type api_carte_zone_type(position pos);

/// Retourne la liste des personnages sur la zone.
std::vector<perso_info> api_carte_zone_perso(position pos);

/// Renvoie le nombre de points nécessaires pour parcourir le chemin le plus
/// court entre deux points. Renvoie -1 en cas de positions invalides ou de
/// chemin inexistant.
int api_distance(position p1, position p2);

/// Renvoie le chemin le plus court entre deux points. Si le chemin n'existe
/// pas, ou si les positions sont invalides, le chemin renvoyé est vide.
std::vector<position> api_chemin(position p1, position p2);

/// Déplace le personnage ``perso`` en suivant un le chemin ``chemin`` donné
/// sous forme d'une suite de ``position``, orientant le personnage sur la zone
/// d'arrivée dans la direction ``orientation``.
erreur api_perso_deplace(perso_info perso, std::vector<position> chemin, orientation direction);

/// Récupère la liste des zones sur lesquelles des personnages ont été aperçus
/// dans la pénombre par ``perso``.
std::vector<position> api_perso_penombre(perso_info perso);

/// Récupère la liste des zones dans le champs de vision de ``perso``.
std::vector<position> api_perso_vision(perso_info perso);

/// Récupère la liste des zones dans le champs de vision de ``perso`` où sont
/// situés un ou plusieurs personnages (amis ou ennemis).
std::vector<position> api_perso_vision_personnages(perso_info perso);

/// Récupère la liste des positions sur lesquelles le palantír du voleur voit
/// d'autre personnages.
std::vector<position> api_palantir_vision();

/// Récupère la liste des positions sur lesquelles l'elfe voit d'autres
/// personnages *via* son attaque spéciale.
std::vector<position> api_elfe_vision();

/// Effectue l'attaque ``attaque`` avec le personnage ``perso`` sur la zone
/// ``pos``.
erreur api_perso_attaque(perso_info perso, attaque_type attaque, position pos);

/// Retourne le temps de recharge restant pour l'attaque ``attaque`` du
/// personnage ``perso``.
int api_perso_attaque_recharge(perso_info perso, attaque_type attaque);

/// Retourne la position du personnage ``perso``.
position api_perso_position(perso_info perso);

/// Retourne le personnage de type ``classe`` de sa propre équipe.
perso_info api_perso_classe_info(perso_classe classe);

/// Retourne le numéro de votre équipe
int api_mon_equipe();

/// Retourne les scores de chaque équipe
std::vector<int> api_scores();

/// Retourne le nombre d'équipes sur le terrain
int api_nombre_equipes();

/// Retourne le numéro du tour actuel
int api_tour_actuel();

/// Retourne le nombre de tours de placements
int api_nombre_tours_placement();

/// Retourne le nombre total de tours
int api_nombre_tours();

/// Affiche le contenu d'une valeur de type perso_classe
void api_afficher_perso_classe(perso_classe v);

/// Affiche le contenu d'une valeur de type zone_type
void api_afficher_zone_type(zone_type v);

/// Affiche le contenu d'une valeur de type attaque_type
void api_afficher_attaque_type(attaque_type v);

/// Affiche le contenu d'une valeur de type orientation
void api_afficher_orientation(orientation v);

/// Affiche le contenu d'une valeur de type erreur
void api_afficher_erreur(erreur v);

/// Affiche le contenu d'une valeur de type position
void api_afficher_position(position v);

/// Affiche le contenu d'une valeur de type perso_info
void api_afficher_perso_info(perso_info v);

const char* api_get_dump();
}

template <typename PythonType, typename CxxType>
PythonType cxx_to_python(CxxType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
PyObject* cxx_to_python<PyObject*, int>(int in)
{
    return PyLong_FromLong(in);
}


template <>
PyObject* cxx_to_python<PyObject*, double>(double in)
{
    return PyFloat_FromDouble(in);
}


template <>
PyObject* cxx_to_python<PyObject*, std::string>(std::string in)
{
    return PyUnicode_FromString(in.c_str());
}


template <>
PyObject* cxx_to_python<PyObject*, bool>(bool in)
{
    return PyBool_FromLong(in);
}

template <typename CxxType>
PyObject* cxx_to_python_array(const std::vector<CxxType>& in)
{
    size_t size = in.size();
    PyObject* out = PyList_New(size);

    for (unsigned int i = 0; i < size; ++i)
        PyList_SET_ITEM(out, i, (cxx_to_python<PyObject*, CxxType>(in[i])));

    return out;
}

template <typename PythonType, typename CxxType>
CxxType python_to_cxx(PythonType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
int python_to_cxx<PyObject*, int>(PyObject* in)
{
    long out = PyLong_AsLong(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
double python_to_cxx<PyObject*, double>(PyObject* in)
{
    double out = PyFloat_AsDouble(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
bool python_to_cxx<PyObject*, bool>(PyObject* in)
{
    return static_cast<bool>(python_to_cxx<PyObject*, int>(in));
}

template <>
std::string python_to_cxx<PyObject*, std::string>(PyObject* in)
{
    const char* out = PyUnicode_AsUTF8(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <typename CxxType>
std::vector<CxxType> python_to_cxx_array(PyObject* in)
{
    if (!PyList_Check(in))
    {
        PyErr_SetString(PyExc_TypeError, "a list is required");
        throw 42;
    }

    std::vector<CxxType> out;
    unsigned int size = PyList_Size(in);
    out.reserve(size);

    for (unsigned int i = 0; i < size; ++i)
        out.push_back(python_to_cxx<PyObject*, CxxType>(PyList_GET_ITEM(in, i)));

    return out;
}

// Type de personnage

template<>
PyObject* cxx_to_python<PyObject*, perso_classe>(perso_classe in)
{
    PyObject* name = PyUnicode_FromString("perso_classe");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
perso_classe python_to_cxx<PyObject*, perso_classe>(PyObject* in)
{
    return static_cast<perso_classe>(python_to_cxx<PyObject*, int>(in));
}

// Type de zone

template<>
PyObject* cxx_to_python<PyObject*, zone_type>(zone_type in)
{
    PyObject* name = PyUnicode_FromString("zone_type");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
zone_type python_to_cxx<PyObject*, zone_type>(PyObject* in)
{
    return static_cast<zone_type>(python_to_cxx<PyObject*, int>(in));
}

// Type d'attaque

template<>
PyObject* cxx_to_python<PyObject*, attaque_type>(attaque_type in)
{
    PyObject* name = PyUnicode_FromString("attaque_type");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
attaque_type python_to_cxx<PyObject*, attaque_type>(PyObject* in)
{
    return static_cast<attaque_type>(python_to_cxx<PyObject*, int>(in));
}

// Orientation du personnage

template<>
PyObject* cxx_to_python<PyObject*, orientation>(orientation in)
{
    PyObject* name = PyUnicode_FromString("orientation");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
orientation python_to_cxx<PyObject*, orientation>(PyObject* in)
{
    return static_cast<orientation>(python_to_cxx<PyObject*, int>(in));
}

// Erreurs possibles

template<>
PyObject* cxx_to_python<PyObject*, erreur>(erreur in)
{
    PyObject* name = PyUnicode_FromString("erreur");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
erreur python_to_cxx<PyObject*, erreur>(PyObject* in)
{
    return static_cast<erreur>(python_to_cxx<PyObject*, int>(in));
}

// Représente une position sur le terrain du jeu

template <>
PyObject* cxx_to_python<PyObject*, position>(position in)
{
    PyObject* tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.x)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.y)));
    return tuple;
}

template <>
position python_to_cxx<PyObject*, position>(PyObject* in)
{
    position out;
    PyObject* i;

    // coordonnée en X
    i = PyTuple_GetItem(in, 0);
    if (i == nullptr)
        throw 42;
    out.x = python_to_cxx<PyObject*, int>(i);

    // coordonnée en Y
    i = PyTuple_GetItem(in, 1);
    if (i == nullptr)
        throw 42;
    out.y = python_to_cxx<PyObject*, int>(i);

    return out;
}

// Représente les informations sur un personnage

template <>
PyObject* cxx_to_python<PyObject*, perso_info>(perso_info in)
{
    PyObject* tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.equipe)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, perso_classe>(in.classe)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.vie)));
    PyTuple_SET_ITEM(tuple, 3, (cxx_to_python<PyObject*, orientation>(in.direction)));
    PyObject* name = PyUnicode_FromString("perso_info");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
perso_info python_to_cxx<PyObject*, perso_info>(PyObject* in)
{
    perso_info out;
    PyObject* i;

    // Équipe à laquelle appartient le personnage
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.equipe = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Classe du personnage
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.classe = python_to_cxx<PyObject*, perso_classe>(i);
    Py_DECREF(i);

    // Vie courante du personnage
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.vie = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Orientation du personnage
    i = cxx_to_python<PyObject*, int>(3);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.direction = python_to_cxx<PyObject*, orientation>(i);
    Py_DECREF(i);

    return out;
}


// Python native wrapper for function carte_taille.
// Retourne la taille de la carte.
static PyObject* p_carte_taille(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, position>(api_carte_taille());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function carte_depart.
// Retourne la position de départ des personnages sur la map.
static PyObject* p_carte_depart(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, position>(api_carte_depart());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function carte_zone_type.
// Retourne la nature de la zone désignée par ``pos``.
static PyObject* p_carte_zone_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, zone_type>(api_carte_zone_type(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function carte_zone_perso.
// Retourne la liste des personnages sur la zone.
static PyObject* p_carte_zone_perso(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_carte_zone_perso(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function distance.
// Renvoie le nombre de points nécessaires pour parcourir le chemin le plus
// court entre deux points. Renvoie -1 en cas de positions invalides ou de
// chemin inexistant.
static PyObject* p_distance(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_p1;
    PyObject* arg_p2;
    if (!PyArg_ParseTuple(args, "OO", &arg_p1, &arg_p2))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_distance(python_to_cxx<PyObject*, position>(arg_p1), python_to_cxx<PyObject*, position>(arg_p2)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function chemin.
// Renvoie le chemin le plus court entre deux points. Si le chemin n'existe
// pas, ou si les positions sont invalides, le chemin renvoyé est vide.
static PyObject* p_chemin(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_p1;
    PyObject* arg_p2;
    if (!PyArg_ParseTuple(args, "OO", &arg_p1, &arg_p2))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_chemin(python_to_cxx<PyObject*, position>(arg_p1), python_to_cxx<PyObject*, position>(arg_p2)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_deplace.
// Déplace le personnage ``perso`` en suivant un le chemin ``chemin`` donné
// sous forme d'une suite de ``position``, orientant le personnage sur la zone
// d'arrivée dans la direction ``orientation``.
static PyObject* p_perso_deplace(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    PyObject* arg_chemin;
    PyObject* arg_direction;
    if (!PyArg_ParseTuple(args, "OOO", &arg_perso, &arg_chemin, &arg_direction))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_perso_deplace(python_to_cxx<PyObject*, perso_info>(arg_perso), python_to_cxx_array<position>(arg_chemin), python_to_cxx<PyObject*, orientation>(arg_direction)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_penombre.
// Récupère la liste des zones sur lesquelles des personnages ont été aperçus
// dans la pénombre par ``perso``.
static PyObject* p_perso_penombre(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    if (!PyArg_ParseTuple(args, "O", &arg_perso))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_perso_penombre(python_to_cxx<PyObject*, perso_info>(arg_perso)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_vision.
// Récupère la liste des zones dans le champs de vision de ``perso``.
static PyObject* p_perso_vision(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    if (!PyArg_ParseTuple(args, "O", &arg_perso))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_perso_vision(python_to_cxx<PyObject*, perso_info>(arg_perso)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_vision_personnages.
// Récupère la liste des zones dans le champs de vision de ``perso`` où sont
// situés un ou plusieurs personnages (amis ou ennemis).
static PyObject* p_perso_vision_personnages(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    if (!PyArg_ParseTuple(args, "O", &arg_perso))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_perso_vision_personnages(python_to_cxx<PyObject*, perso_info>(arg_perso)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function palantir_vision.
// Récupère la liste des positions sur lesquelles le palantír du voleur voit
// d'autre personnages.
static PyObject* p_palantir_vision(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_palantir_vision());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function elfe_vision.
// Récupère la liste des positions sur lesquelles l'elfe voit d'autres
// personnages *via* son attaque spéciale.
static PyObject* p_elfe_vision(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_elfe_vision());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_attaque.
// Effectue l'attaque ``attaque`` avec le personnage ``perso`` sur la zone
// ``pos``.
static PyObject* p_perso_attaque(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    PyObject* arg_attaque;
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "OOO", &arg_perso, &arg_attaque, &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_perso_attaque(python_to_cxx<PyObject*, perso_info>(arg_perso), python_to_cxx<PyObject*, attaque_type>(arg_attaque), python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_attaque_recharge.
// Retourne le temps de recharge restant pour l'attaque ``attaque`` du
// personnage ``perso``.
static PyObject* p_perso_attaque_recharge(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    PyObject* arg_attaque;
    if (!PyArg_ParseTuple(args, "OO", &arg_perso, &arg_attaque))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_perso_attaque_recharge(python_to_cxx<PyObject*, perso_info>(arg_perso), python_to_cxx<PyObject*, attaque_type>(arg_attaque)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_position.
// Retourne la position du personnage ``perso``.
static PyObject* p_perso_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_perso;
    if (!PyArg_ParseTuple(args, "O", &arg_perso))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, position>(api_perso_position(python_to_cxx<PyObject*, perso_info>(arg_perso)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function perso_classe_info.
// Retourne le personnage de type ``classe`` de sa propre équipe.
static PyObject* p_perso_classe_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_classe;
    if (!PyArg_ParseTuple(args, "O", &arg_classe))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, perso_info>(api_perso_classe_info(python_to_cxx<PyObject*, perso_classe>(arg_classe)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function mon_equipe.
// Retourne le numéro de votre équipe
static PyObject* p_mon_equipe(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_mon_equipe());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function scores.
// Retourne les scores de chaque équipe
static PyObject* p_scores(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_scores());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function nombre_equipes.
// Retourne le nombre d'équipes sur le terrain
static PyObject* p_nombre_equipes(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_nombre_equipes());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function tour_actuel.
// Retourne le numéro du tour actuel
static PyObject* p_tour_actuel(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_tour_actuel());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function nombre_tours_placement.
// Retourne le nombre de tours de placements
static PyObject* p_nombre_tours_placement(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_nombre_tours_placement());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function nombre_tours.
// Retourne le nombre total de tours
static PyObject* p_nombre_tours(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_nombre_tours());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_perso_classe.
// Affiche le contenu d'une valeur de type perso_classe
static PyObject* p_afficher_perso_classe(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_perso_classe(python_to_cxx<PyObject*, perso_classe>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_zone_type.
// Affiche le contenu d'une valeur de type zone_type
static PyObject* p_afficher_zone_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_zone_type(python_to_cxx<PyObject*, zone_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_attaque_type.
// Affiche le contenu d'une valeur de type attaque_type
static PyObject* p_afficher_attaque_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_attaque_type(python_to_cxx<PyObject*, attaque_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_orientation.
// Affiche le contenu d'une valeur de type orientation
static PyObject* p_afficher_orientation(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_orientation(python_to_cxx<PyObject*, orientation>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_erreur.
// Affiche le contenu d'une valeur de type erreur
static PyObject* p_afficher_erreur(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_erreur(python_to_cxx<PyObject*, erreur>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_position.
// Affiche le contenu d'une valeur de type position
static PyObject* p_afficher_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_position(python_to_cxx<PyObject*, position>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_perso_info.
// Affiche le contenu d'une valeur de type perso_info
static PyObject* p_afficher_perso_info(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_perso_info(python_to_cxx<PyObject*, perso_info>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

static PyObject* p_get_dump(PyObject* self, PyObject* args)
{
    const char* dump = api_get_dump();
    PyObject* py_dump = PyUnicode_FromString(dump);
    return py_dump;
}

// API function to register.
static PyMethodDef api_callback[] = {
    {"carte_taille", p_carte_taille, METH_VARARGS, "carte_taille"},
    {"carte_depart", p_carte_depart, METH_VARARGS, "carte_depart"},
    {"carte_zone_type", p_carte_zone_type, METH_VARARGS, "carte_zone_type"},
    {"carte_zone_perso", p_carte_zone_perso, METH_VARARGS, "carte_zone_perso"},
    {"distance", p_distance, METH_VARARGS, "distance"},
    {"chemin", p_chemin, METH_VARARGS, "chemin"},
    {"perso_deplace", p_perso_deplace, METH_VARARGS, "perso_deplace"},
    {"perso_penombre", p_perso_penombre, METH_VARARGS, "perso_penombre"},
    {"perso_vision", p_perso_vision, METH_VARARGS, "perso_vision"},
    {"perso_vision_personnages", p_perso_vision_personnages, METH_VARARGS, "perso_vision_personnages"},
    {"palantir_vision", p_palantir_vision, METH_VARARGS, "palantir_vision"},
    {"elfe_vision", p_elfe_vision, METH_VARARGS, "elfe_vision"},
    {"perso_attaque", p_perso_attaque, METH_VARARGS, "perso_attaque"},
    {"perso_attaque_recharge", p_perso_attaque_recharge, METH_VARARGS, "perso_attaque_recharge"},
    {"perso_position", p_perso_position, METH_VARARGS, "perso_position"},
    {"perso_classe_info", p_perso_classe_info, METH_VARARGS, "perso_classe_info"},
    {"mon_equipe", p_mon_equipe, METH_VARARGS, "mon_equipe"},
    {"scores", p_scores, METH_VARARGS, "scores"},
    {"nombre_equipes", p_nombre_equipes, METH_VARARGS, "nombre_equipes"},
    {"tour_actuel", p_tour_actuel, METH_VARARGS, "tour_actuel"},
    {"nombre_tours_placement", p_nombre_tours_placement, METH_VARARGS, "nombre_tours_placement"},
    {"nombre_tours", p_nombre_tours, METH_VARARGS, "nombre_tours"},
    {"afficher_perso_classe", p_afficher_perso_classe, METH_VARARGS, "afficher_perso_classe"},
    {"afficher_zone_type", p_afficher_zone_type, METH_VARARGS, "afficher_zone_type"},
    {"afficher_attaque_type", p_afficher_attaque_type, METH_VARARGS, "afficher_attaque_type"},
    {"afficher_orientation", p_afficher_orientation, METH_VARARGS, "afficher_orientation"},
    {"afficher_erreur", p_afficher_erreur, METH_VARARGS, "afficher_erreur"},
    {"afficher_position", p_afficher_position, METH_VARARGS, "afficher_position"},
    {"afficher_perso_info", p_afficher_perso_info, METH_VARARGS, "afficher_perso_info"},
    {"get_dump", p_get_dump, METH_VARARGS, "get_dump"},
    {nullptr, nullptr, 0, nullptr}
};

// Initialize C module.
PyMODINIT_FUNC PyInit__api()
{
    static struct PyModuleDef apimoduledef = {
        PyModuleDef_HEAD_INIT,
        "_api",
        "API module",
        -1,
        api_callback,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
    };
    return PyModule_Create(&apimoduledef);
}

// Load a Python module.
static PyObject* _import_module(const char* m)
{
    PyObject* name = PyUnicode_FromString(m);
    PyObject* mod = PyImport_Import(name);
    Py_DECREF(name);
    if (mod == nullptr)
        if (PyErr_Occurred())
        {
            PyErr_Print();
            abort();
        }
    return mod;
}

// Initialize Python VM, register API functions, and load .py file.
static void _init_python()
{
    static wchar_t empty_string[] = L"";
    static wchar_t *argv[] = { (wchar_t *) &empty_string, nullptr };

    const char* champion_path;

    champion_path = getenv("CHAMPION_PATH");
    if (champion_path == nullptr)
        champion_path = ".";

    setenv("PYTHONPATH", champion_path, 1);

    static wchar_t program_name[] = L"stechec";
    Py_SetProgramName(program_name);

    PyImport_AppendInittab("_api", PyInit__api);
    Py_Initialize();
    PySys_SetArgvEx(1, argv, 0);

    // Import a Champion module with an uppercase letter to avoid conflict with
    // champion.so
    champ_module = _import_module("Champion");
    py_module = _import_module("api");
}

// Flush stdout and stderr
static void flush_std_files()
{
    PyObject *fout = PySys_GetObject("stdout");
    PyObject *ferr = PySys_GetObject("stderr");
    PyObject *tmp;

    if (fout != nullptr && fout != Py_None) {
        tmp = PyObject_CallMethod(fout, "flush", "");
        if (tmp == nullptr)
            PyErr_WriteUnraisable(fout);
        else
            Py_DECREF(tmp);
    }

    if (ferr != nullptr && ferr != Py_None) {
        tmp = PyObject_CallMethod(ferr, "flush", "");
        if (tmp == nullptr)
            PyErr_Clear();
        else
            Py_DECREF(tmp);
    }
}

// Run a Python function.
static PyObject* _call_python_function(const char* name)
{
    static bool initialized = false;

    if (!initialized)
    {
        initialized = true;
        _init_python();
    }

    PyObject *arglist, *func;
    PyObject *result = nullptr;

    func = PyObject_GetAttrString(champ_module, name);
    if (func && PyCallable_Check(func))
    {
        arglist = Py_BuildValue("()");
        result = PyEval_CallObject(func, arglist);
        Py_XDECREF(arglist);
        Py_DECREF(func);
    }
    if (result == nullptr && PyErr_Occurred())
    {
        PyErr_Print();
        abort();
    }

    flush_std_files();
    return result;
}


// Functions called from Stechec to Python.

extern "C" void partie_init()
{
    PyObject* _retval = _call_python_function("partie_init");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void jouer_placement()
{
    PyObject* _retval = _call_python_function("jouer_placement");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void jouer_deplacement()
{
    PyObject* _retval = _call_python_function("jouer_deplacement");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void jouer_attaque()
{
    PyObject* _retval = _call_python_function("jouer_attaque");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void partie_fin()
{
    PyObject* _retval = _call_python_function("partie_fin");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}
